---
title: Erstellen eines JSON-Web-Tokens
description: Erstellen Sie ein JSON-Web-Token (JWT), das mit Adobe IMS-APIs mit einem AEM-Zugriffs-Token ausgetauscht werden kann.
type: Documentation
role: Developer
level: Beginner, Intermediate
version: Cloud Service
feature: Adaptive Forms
topic: Development
jira: KT-8184
thumbnail: 8184.jpg
exl-id: 394ed621-1106-4b2a-a6b7-2efa5867f5b1
duration: 45
source-git-commit: f23c2ab86d42531113690df2e342c65060b5c7cd
workflow-type: tm+mt
source-wordcount: '112'
ht-degree: 100%

---

# Erstellen eines JSON-Web-Tokens

JSON-Web-Token bieten eine offene, branchen端bliche RFC-7519-Methode zur sicheren Darstellung von Forderungen zwischen zwei Parteien. In diesem Beispiel wurden JWT.io-Bibliotheken verwendet, um das JWT zu generieren.
Die Dienstanmeldeinformationen, die im vorherigen Schritt heruntergeladen wurden, enthalten den privaten Schl端ssel im PKCS#1-Format. Um den privaten Schl端ssel aus dieser Zeichenfolge zu extrahieren, haben wir [BouncyCastle](https://www.bouncycastle.org/)-Bibliotheken verwendet. Die Kryptobibliotheken, die Teil von Java sind, unterst端tzen das PKCS#1-Format nicht.

Der folgende Code wurde zum Generieren des JWT verwendet:

```java
public String getJWTToken()
    {
            Security.addProvider(new BouncyCastleProvider());
            RSAPrivateKey privateKey = null;
            GetServiceCredentials getCredentials = new GetServiceCredentials();
            try 
            {

                long now = System.currentTimeMillis();
                Long expirationTime = now + TimeUnit.MINUTES.toMillis(5);
                // get the private key string from the service credentials
                String privateKeyString = getCredentials.getPRIVATE_KEY();
              //The JWT signature algorithm we use to sign the token
                SignatureAlgorithm sa = SignatureAlgorithm.RS256;
                
                
                Reader targetReader = new StringReader(privateKeyString);
                // PEMParser removes the unnecessary headers and decodes the underlying Base64 PEM data into a binary format.
                PEMParser pemParser = new PEMParser(targetReader);
                // tores the result generated by the pEMParser
                Object object = pemParser.readObject();
                JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
                KeyPair kp = converter.getKeyPair((PEMKeyPair) object);
                privateKey = (RSAPrivateKey) kp.getPrivate();
                
              //Let's set the JWT Claims

                Map < String, Object > jwtClaims = new HashMap < String, Object > ();
                jwtClaims.put("iss", getCredentials.getORG_ID());
                jwtClaims.put("sub", getCredentials.getTECH_ACCT());
                jwtClaims.put("exp", expirationTime);
                jwtClaims.put("aud", "https://" + getCredentials.getIMS_ENDPOINT() + "/c/" + getCredentials.getCLIENT_ID());
                String metascopes[] = new String[] { getCredentials.getMETASCOPE_ID() };
                    
                for (String metascope: metascopes)
                {
                            jwtClaims.put("https://" + getCredentials.getIMS_ENDPOINT() + "/s/" + metascope, java.lang.Boolean.TRUE);
                }

                
                // Create the final JWT token
                String jwtToken = Jwts.builder().setClaims(jwtClaims).signWith(sa, privateKey).compact();
                    System.out.println("Got JWT Token " + jwtToken);
                    pemParser.close();
                return jwtToken;

            } catch (IOException e) {
                
                    System.out.println("The error is " + e.getMessage());
            }
            return null;

    }
```
